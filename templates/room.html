{% extends "base.html" %}
{% block title %}Комната {{ room_name }}{% endblock %}

{% block content %}
<div class="row">
  <div class="col-md-10 offset-md-1">
    <h2 class="mb-3">Комната: {{ room_name }}</h2>

    <div id="messages" class="border rounded p-3 bg-light" style="height: 420px; overflow-y: auto;">
      <!-- Сообщения будут подгружаться сюда -->
    </div>

    <div class="mt-3 d-flex gap-2">
      <input id="messageInput" placeholder="Написать сообщение" class="form-control" autocomplete="off" required>
      <button id="sendBtn" class="btn btn-success">Отправить</button>

      <form action="{{ url_for('leave_room') }}" method="post">
        <button class="btn btn-outline-secondary">Выйти из комнаты</button>
      </form>
    </div>

    <div class="mt-2">
      <small class="text-muted">Вы: {{ nickname or "Гость (войдите для отправки)" }}</small>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
const roomName = {{ room_name|tojson }};
const messagesDiv = document.getElementById('messages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');

let lastMessageId = null; // последний загруженный id
const MAX_MESSAGES = 100;

// функция обновления сообщений без дергания скролла
async function loadMessages() {
  try {
    let url = `/get_messages/${encodeURIComponent(roomName)}`;
    if (lastMessageId) url += `?after_id=${lastMessageId}`;
    const res = await fetch(url);
    if (!res.ok) return;
    const data = await res.json();
    if (!data.length) return;

    const scrollTop = messagesDiv.scrollTop;
    const scrollBottom = messagesDiv.scrollHeight - messagesDiv.clientHeight - scrollTop;

    data.forEach(m => {
      const div = document.createElement('div');
      const time = document.createElement('small');
      time.className = 'text-muted';
      time.textContent = `[${m.time}] `;
      const bold = document.createElement('strong');
      bold.textContent = m.nickname + ': ';
      div.appendChild(time);
      div.appendChild(bold);
      div.appendChild(document.createTextNode(m.text));
      messagesDiv.appendChild(div);
      lastMessageId = m.id;
    });

    // НЕ трогаем scrollTop — пользователь остаётся там, где поставил
  } catch(e) {
    console.error("Ошибка при обновлении сообщений", e);
  }
}

// отправка сообщения через fetch (без перезагрузки)
async function sendMessage() {
  const text = messageInput.value.trim();
  if (!text) return;
  try {
    const formData = new FormData();
    formData.append('message', text);
    const res = await fetch(`/send_message/${encodeURIComponent(roomName)}`, {
      method: 'POST',
      body: formData
    });
    if (res.ok) {
      messageInput.value = '';
      loadMessages(); // подгружаем новые сообщения
    }
  } catch(e) {
    console.error("Ошибка при отправке сообщения", e);
  }
}

sendBtn.addEventListener('click', sendMessage);
messageInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    sendMessage();
  }
});

// автообновление каждые 2.5 сек
setInterval(loadMessages, 2500);

// начальная загрузка последних сообщений
loadMessages();
</script>
{% endblock %}
